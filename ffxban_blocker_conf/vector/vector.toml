# Источник данных: читаем access.log Xray из директории, пробрасываемой с хоста
[sources.xray_access_logs]
  type = "file"
  include = ["/var/log/remnanode/access.log"]
  # Начинаем с конца файла: не обрабатываем старые записи при перезапуске
  read_from = "end"

# Трансформация: парсим строку лога, извлекаем IP и email
[transforms.parse_xray_log]
  type = "remap"
  inputs = ["xray_access_logs"]
  source = '''
    # Поддерживаем форматы: "from 1.2.3.4:port" и "from tcp:1.2.3.4:port"
    pattern = r'from (tcp:)?(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):\d+.*? email: (?P<email>\S+)'

    parsed, err = parse_regex(.message, pattern)
    if err != null {
      log("Не удалось распарсить строку лога: " + err, level: "warn")
      abort
    }

    node_name, node_name_err = get_env_var("NODE_NAME")
    if node_name_err != null {
      node_name = "unknown"
    }

    . = {
      "user_email":  parsed.email,
      "source_ip":   parsed.ip,
      "node_name":   node_name,
      "timestamp":   to_string(now())
    }
  '''

# Назначение: отправляем данные на центральный Observer по HTTPS
# ВАЖНО: замените HEAD_DOMAIN на ваш реальный домен Observer (например: observer.example.com)
[sinks.central_ffxban_api]
  type = "http"
  inputs = ["parse_xray_log"]
  uri = "https://HEAD_DOMAIN:38213/"
  method = "post"
  encoding.codec = "json"
  compression = "gzip"

  [sinks.central_ffxban_api.batch]
    max_events    = 100
    timeout_secs  = 5

  [sinks.central_ffxban_api.request]
    retry_attempts     = 5
    retry_backoff_secs = 2
    timeout_secs       = 10

  # TLS: проверяем сертификат сервера.
  # Let's Encrypt — доверенный CA, оставьте verify_certificate = true.
  # Если используете self-signed сертификат — установите verify_certificate = false.
  [sinks.central_ffxban_api.tls]
    verify_certificate = true
    verify_hostname    = true
